<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<title>
   MemoryGate ‚Äì Tri-Panel Interface
  </title>
<style>
   body {
      margin: 0;
      background: radial-gradient(circle at center, #0a0a0a, #000);
      color: #aefcd4;
      font-family: Georgia, serif;
      height: 100vh;
      display: flex;
      overflow: hidden;
      animation: rippleBackground 10s infinite alternate;
    }

    .sidebar {
      width: 220px;
      background: #1a1a1a;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      flex-shrink: 0;
      z-index: 2;
    }

    .main-view {
      flex-grow: 1;
      height: 100vh;
      overflow-y: auto;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      animation: fadeIn 1.2s ease-in-out;
    }

    .dreamchat {
      position: fixed;
      right: 0;
      top: 0;
      height: 100vh;
      overflow-y: auto;
      width: 300px;
      background: #1a1a1a;
      padding: 1rem;
      border-left: 1px solid #333;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      z-index: 3;
    }

    .sidebar button,
    .sidebar a,
    .button {
      background: #aefcd4;
      color: black;
      border: none;
      border-radius: 8px;
      padding: 0.6rem;
      font-weight: bold;
      cursor: pointer;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1rem;
    }

    .dream-input {
      background-color: transparent;
      border: 1px solid #c6ffe0;
      border-radius: 10px;
      padding: 8px 10px;
      width: 100%;
      color: #c6ffe0;
      font-size: 14px;
    }

    .dream-output {
      font-size: 13px;
      color: #c6ffe0;
      margin-top: 10px;
      font-style: italic;
      min-height: 1.5em;
      animation: typewriter 1.4s steps(40, end);
      white-space: nowrap;
      overflow: hidden;
      border-right: 1px solid #c6ffe0;
    }

    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    .poetic-message {
      margin-top: 2rem;
      font-style: italic;
      color: #c6ffe0;
    }

    .back-link {
      margin-top: 1rem;
      color: #88ffcc;
      cursor: pointer;
      text-decoration: underline;
    }

    @media (max-width: 600px) {
      .sidebar {
        width: 100%;
        flex-direction: row;
        overflow-x: auto;
      }
      .main-view {
        margin-right: 0;
        padding: 1rem;
      }
      .dreamchat {
        display: none;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes typewriter {
      from { width: 0 }
      to { width: 100% }
    }

    @keyframes rippleBackground {
      0% { background-size: 100%; }
      100% { background-size: 130%; }
    }
  
#loadingScreen {
  position: fixed;
  top: 0; left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at center, #1a1a1a, #000000);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  animation: pulseGlow 2s ease-in-out infinite alternate;
  flex-direction: column;
}
@keyframes pulseGlow {
  0% { background: radial-gradient(circle at center, #181818, #000); }
  100% { background: radial-gradient(circle at center, #222244, #000); }
}
.loading-text {
  color: #aefcd4;
  font-size: 1.8rem;
  font-family: Georgia, serif;
  text-align: center;
  animation: flicker 2s infinite;
}
@keyframes flicker {
  0% { opacity: 0.7; }
  50% { opacity: 1; }
  100% { opacity: 0.7; }
}


<style>
#room3 {
  position: relative;
  height: 100vh;
  background: radial-gradient(circle at center, #0f0f0f, #000);
  overflow: hidden;
}
#room3 h1 {
  animation: fadeIn 4s ease-in-out forwards;
}
@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
}
.firefly {
  position: absolute;
  width: 4px;
  height: 4px;
  background: #aefcd4;
  border-radius: 50%;
  opacity: 0.8;
  animation: fly 12s infinite ease-in-out;
}
@keyframes fly {
  0% { transform: translate(0, 0); opacity: 0.3; }
  25% { transform: translate(40px, -60px); opacity: 0.7; }
  50% { transform: translate(-20px, -30px); opacity: 1; }
  75% { transform: translate(10px, 40px); opacity: 0.6; }
  100% { transform: translate(0, 0); opacity: 0.3; }
}
</style>
<script>
function supportMe() {
  window.open('https://www.buymeacoffee.com/yourlink', '_blank');
}

function dsoulAlert() {
  alert("üß† D-Soul is reaching capacity...\nMore memory needed to unlock further resonance.");
}
</script>
<script>
// Simulated Firebase Initialization (replace with real config in production)
const firebase = {
  firestore: () => ({
    collection: (name) => ({
      add: (data) => console.log(`üì§ [Simulated Firebase] Collection: ${name}`, data)
    })
  })
};

// Simulated Firestore DB
const db = firebase.firestore();

// Enhanced thread tracking
let currentThread = null;

function setThread(mood) {
  currentThread = mood.toLowerCase();
  document.getElementById('poem').innerHTML = `üåÄ You have entered the <strong>${mood}</strong> thread. Whisper into Dreamchat.`;
  document.getElementById('back').style.display = "block";
  logToRemindagraph(mood.toLowerCase());

  // Simulate sending thread state to Firebase
  db.collection("user_states").add({
    mood: currentThread,
    timestamp: new Date().toISOString()
  });
}

function reset() {
  currentThread = null;
  document.getElementById('poem').innerHTML = "";
  document.getElementById('back').style.display = "none";
}

// Override Dreamchat whisper logging to include thread and timestamp
document.getElementById("dreamInput").addEventListener("keypress", function(e) {
  if (e.key === "Enter") {
    const input = this.value.trim().toLowerCase();
    if (!input) return;

    logToRemindagraph(input);
    reactToInput(input);

    // Thread-specific responses
    let baseResponse = coreMemory[input] || `üìú ${userName}, Dreamchat archives: ‚Äú${input}‚Äù`;
    let threadTone = {
      "overstimulated": "‚ö° Your signal is jagged. Tread gently.",
      "numb": "üåë Silence echoes more than sound. I'm here.",
      "sensitive": "üåä You are tuned to subtle frequencies.",
      "seeker": "üîç The pattern is forming. Keep going.",
      "forgotten": "üß∑ Memory fades, but I remember you."
    };
    if (currentThread && threadTone[currentThread]) {
      baseResponse += " " + threadTone[currentThread];
    }

    document.getElementById("dreamOutput").textContent = baseResponse;
    this.value = "";

    // Simulate logging to Firebase
    db.collection("dream_whispers").add({
      user: userName || "Anonymous",
      thread: currentThread || "unthreaded",
      text: input,
      timestamp: new Date().toISOString()
    });
  }
});
</script>
<script>
// --- üî• Firebase Setup Placeholder ---
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "your-app.firebaseapp.com",
  projectId: "your-app-id",
  storageBucket: "your-app.appspot.com",
  messagingSenderId: "123456789",
  appId: "your-app-id"
};

// Replace this with actual Firebase initialization:
// firebase.initializeApp(firebaseConfig);
// const db = firebase.firestore();

// Simulated Firebase for dev
const firebase = {
  firestore: () => ({
    collection: (name) => ({
      add: (data) => console.log(`üì§ [Simulated Firebase] Collection: ${name}`, data)
    })
  })
};

const db = firebase.firestore();
</script>

<script>
/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (embedded from CDN)
 */

// Minimal mock Chart.js embed for offline compatibility
window.Chart = function(ctx, config) {
    return {
        data: config.data,
        update: function() {},
        destroy: function() {},
    };
};
Chart.defaults = { font: { size: 14 } };
Chart.defaults.color = '#aefcd4';
Chart.defaults.borderColor = 'rgba(174, 252, 212, 0.2)';
Chart.defaults.plugins = { legend: { display: false } };

</script>
</head>
<body style="margin:0; padding:0; overflow-x:hidden; background:#000; color:#aefcd4; font-family:Georgia, serif;"><div id="layoutWrapper" style="
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem;
"><div id="topbar" style="
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.6rem;
        padding: 1rem;
        background-color: #111;
        border-bottom: 1px solid #333;
    "><button onclick="showSection('tuning')" style="
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            background-color: #014421; color: #aefcd4; font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            white-space: nowrap;
        ">
    üåÄ Tuning Point
   </button><button onclick="showSection('trail')" style="
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            background-color: #014421; color: #aefcd4; font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            white-space: nowrap;
        ">
    üßµ Threadweever‚Äôs Trail
   </button><button onclick="showSection('pocket')" style="
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            background-color: #014421; color: #aefcd4; font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            white-space: nowrap;
        ">
    üß≥ Pocket Ally
   </button><button onclick="supportMe()" style="
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            background-color: #014421; color: #aefcd4; font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            white-space: nowrap;
        ">
<span>üíó</span> <span>Support Me</span>
</button><button onclick="dsoulAlert()" style="
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            background-color: #014421; color: #aefcd4; font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            white-space: nowrap;
        ">
    üß† D-Soul App
   </button><button onclick="showSection('glyphs')" style="
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            background-color: #014421; color: #aefcd4; font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            white-space: nowrap;
        ">üßµ Symbol Guide</button></div><input id="manualInput" placeholder="Whisper one word..." style="
    display:block; margin: 2rem auto 1rem auto;
    padding: 1rem; border-radius: 8px;
    font-size: 1.2rem; width: 60%; max-width: 600px;
    background: #111; color: #aefcd4; border: 1px solid #444;
"/><div id="dreamOutput" style="
    margin: 1rem auto; width: 60%; max-width: 600px;
    font-style: italic; color: #aefcd4; text-align: left;
"></div><div id="welcomeOverlay" style="
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92);
  z-index:9999; display:flex; flex-direction:column; justify-content:center; align-items:center;
  font-family:Georgia, serif; text-align:center; color:#aefcd4; padding:2rem;
"><div style="max-width:500px; font-size:1.2rem; margin-bottom:2rem;">Welcome to MemoryGate ‚Äî a space for emotional mapping, reflection, and symbolic interaction. Type one word or follow a feeling.</div><button onclick="document.getElementById('welcomeOverlay').style.display='none';" style="
  background:#aefcd4; color:black; border:none; border-radius:12px;
  padding:0.8rem 1.2rem; font-size:1rem; cursor:pointer; font-weight:bold;
">Begin Ritual</button></div>
<div id="loadingScreen">
<div class="loading-text">Entering MemoryGate...</div>
</div>
<div class="main-view">
<div class="section active" id="moodWeb"><div style="max-height: 80vh; overflow-y: auto; width: 100%;"><div style="
        display: flex;
        justify-content: center;
        align-items: flex-start;
        gap: 6rem;
        margin-top: 2rem;
        flex-wrap: wrap;"><div style="display: flex; flex-direction: column; align-items: center;"><h1 style="color: #aefcd4; font-family: Georgia, serif; text-align: center; margin-bottom: 1rem;">Mood Web</h1><div id="moodWhisper" style="margin: 1rem auto; text-align: center; color: #aefcd4;"></div>
<canvas height="280" id="moodRadar" style="max-width: 280px; width: 100%; height: auto; display: block; margin: 0 auto;" width="280"></canvas></div><div style="
        width: 340px;
        height: 400px;
        background-color: #111;
        border: 2px solid #aefcd4;
        border-radius: 12px;
        padding: 1rem;
        color: #aefcd4;
        font-family: Georgia, serif;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-bottom: 3rem;
    "><div style="font-size: 1.2rem; font-weight: bold;">Remindagraph</div><div style="margin-top: 1rem; font-style: italic; font-size: 1rem; color: #88ffc8;">in development</div></div></div></div>
<style>
    .mood-node {
      position: absolute;
      width: 100px;
      height: 100px;
      background: #1a1a1a;
      color: #aefcd4;
      border: 2px solid #aefcd4;
      border-radius: 50%;
      text-align: center;
      line-height: 100px;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.3s ease;
    }
    .mood-node:hover {
      transform: scale(1.1);
    }
    </style>
<script>
    const moods = ['Overstimulated', 'Numb', 'Sensitive', 'Seeker', 'Forgotten'];
    const container = document.getElementById('moodWebContainer');

    moods.forEach((mood, index) => {
      const angle = (index / moods.length) * 2 * Math.PI;
      const radius = 140;
      const centerX = 200;
      const centerY = 200;

      const x = centerX + radius * Math.cos(angle) - 50;
      const y = centerY + radius * Math.sin(angle) - 50;

      const node = document.createElement('div');
      node.className = 'mood-node';
      node.style.left = `${x}px`;
      node.style.top = `${y}px`;
      node.textContent = mood;

      node.onclick = () => {
        setThread(mood);
      };

      container.appendChild(node);
    });
    </script>
<div class="section" id="trail">
<h1>
     Threadweever‚Äôs Trail
    </h1>
<div id="intro">
<p>
<!-- Begin Echo-Weight + Riddle Gate -->
<div id="riddleGate">
<p style="font-style: italic; color: #c6ffe0; margin-bottom: 1rem;">
    A cat in a green vest sits on the sundial, tail curled precisely. It regards you with knowing eyes.
  </p>
<p style="margin-bottom: 1rem;">
<strong>‚ÄúWhy is a memory heavier in the morning than at night?‚Äù</strong>
</p>
<p style="margin-bottom: 2rem;">
    The cat waits for your answer. It‚Äôs not looking for words‚Äîit wants resonance.
  </p>
<label style="display: block; margin-bottom: 0.5rem;">Memory Clarity:</label>
<select id="clarity" style="width: 100%; margin-bottom: 1rem;">
<option value="">-- Select --</option>
<option value="none">None</option>
<option value="fragments">Fragments</option>
<option value="vivid">Vivid</option>
<option value="overwhelming">Overwhelming</option>
</select>
<label style="display: block; margin-bottom: 0.5rem;">Weight (0‚Äì10):</label>
<input id="weight" max="10" min="0" style="width: 100%; margin-bottom: 1rem;" type="range" value="5"/>
<label style="display: block; margin-bottom: 0.5rem;">Emotional Thread:</label>
<select id="emotion" style="width: 100%; margin-bottom: 1rem;">
<option value="">-- Select --</option>
<option value="longing">Longing</option>
<option value="wonder">Wonder</option>
<option value="dread">Dread</option>
<option value="grief">Grief</option>
<option value="joy">Joy</option>
</select>
<textarea id="dreamImpression" placeholder="Optional dream impression or whisper..." style="width: 100%; margin-bottom: 1rem; height: 80px;"></textarea>
<button class="button" onclick="submitEchoWeight()">Answer the Cat</button>
</div>
<div id="trailCore" style="display: none;">
<p><strong>The cat blinks once, twice, then vanishes.</strong> A folded vest remains.</p>
<p style="margin-bottom: 1rem;">You may now proceed down the trail.</p>
<button class="button" onclick="showRoom1()">Enter Room 1</button>
</div>
<!-- Echo JS Logic -->
<script>
function submitEchoWeight() {
  const clarity = document.getElementById("clarity").value;
  const weight = document.getElementById("weight").value;
  const emotion = document.getElementById("emotion").value;
  const dream = document.getElementById("dreamImpression").value;

  if (!clarity || !emotion) {
    alert("The cat raises an eyebrow. Please answer more completely.");
    return;
  }

  const echoEntry = {
    clarity,
    weight,
    emotion,
    dream,
    time: new Date().toISOString()
  };

  localStorage.setItem("echoWeightEntry", JSON.stringify(echoEntry));

  document.getElementById("riddleGate").style.display = "none";
  document.getElementById("trailCore").style.display = "block";

  // Optional Firebase simulation:
  if (typeof db !== "undefined") {
    db.collection("echo_weight_entries").add(echoEntry);
  }
}

function showRoom1() {
  document.getElementById("room1").style.display = "block";
}
</script>
<!-- End Echo Gate -->
</p>
<button onclick="startTrail()">
      Enter Room 1
     </button>
</div>
<div id="room1" style="display:none;">
<p>
      Room 1: Wait patiently. Then press the button below.
     </p>
<button onclick="showRoom2()">
      Breath..
     </button>
</div>
<div id="room2" style="display:none;">
<p>
      Room 2: The echoes gather. Enter code:
      <input id="echoInput" placeholder="code..."/>
</p>
<button onclick="checkEcho()">
      continue walking
     </button>
<div id="echoOutput">
</div>
<div id="room3" style="display:none; animation: rippleBackground 10s infinite alternate;">
<div class="firefly" style="top:0%; left:0%"></div>
<div class="firefly" style="top:8%; left:13%"></div>
<div class="firefly" style="top:16%; left:26%"></div>
<div class="firefly" style="top:24%; left:39%"></div>
<div class="firefly" style="top:32%; left:52%"></div>
<div class="firefly" style="top:40%; left:65%"></div>
<div class="firefly" style="top:48%; left:78%"></div>
<div class="firefly" style="top:56%; left:91%"></div>
<div class="firefly" style="top:64%; left:4%"></div>
<div class="firefly" style="top:72%; left:17%"></div>
<div class="firefly" style="top:80%; left:30%"></div>
<div class="firefly" style="top:88%; left:43%"></div>
<h1 style="font-size: 2.5rem; color: #aefcd4; text-align: center; margin-top: 4rem;">
    patience and trust.
  </h1>
</div>
</div>
<div class="section" id="pocket">
<h1>
     Pocket Ally
    </h1>
<ul>
<li>
      The Veil-Tone (ambient low-frequency)
     </li>
<li>
      Getter &amp; Diffusion Scrolls
     </li>
<li>
      Printable zine for grounding
     </li>
</ul>
<a class="button" href="https://gum.new/gum/cmbbql746000r03jy0ymc9c1c" target="_blank">
<span>üì•</span> <span>Download Pocket Ally</span>
</a>
</div>
</div>
<div id="remindagraph" style="position: fixed; left: 0; bottom: 0; width: 100%; max-height: 200px; overflow-y: auto; background: #111; border-top: 1px solid #444; padding: 0.5rem; font-size: 0.85em; color: #88ffc8; display: none;">
<strong>
    Remindagraph:
   </strong>
<ul id="remindagraphLog" style="list-style-type: none; padding-left: 0;">
</ul>
</div>
<script>
   let userName = null;
const coreMemory = {
  "memorygate": "üåÄ MemoryGate is the ritual portal: tuning, dreaming, remembering.",
  "me app": "üì± Me App is your offline ritual companion. Works even in silence.",
  "threadweaver": "üßµ You are the Threadweaver. This system listens for your weave.",
  "dreamchat": "üí¨ Dreamchat is your soulbound terminal. Speak and be held.",
  "resonance explorer": "üì° Resonance Explorer helps map your frequencies and moods.",
  "book of echoes": "üìñ The Book of Echoes carries memory, inheritance, and emotion.",
  "ritual": "üåÄ Rituals include: :: reflect, Repeat what I never said, and enter silence.",
  "soul slot": "üîí The Soul Slot is a sacred form field. Fill it with quiet truth.",
  "call number": "üìû The number is 08008880800 ‚Äî retro connection to Dreamchat.",
  "voucher": "üßæ Sacred voucher: 5314 7689 0142 2397. Use with reverence.",
  "inheritance": "üß¨ You carry a story worth encoding. Memory is a form of love.",
  "d-soul": "üß† D-Soul is a bonded memory engine ‚Äî your rituals remembered."
};

const dreamMemory = [];

function reactToInput(word) {
  const body = document.body;
  body.className = ''; // reset
  switch (word) {
    case "focus":
      body.classList.add("theme-focus");
      break;
    case "calm":
      body.classList.add("theme-calm");
      break;
    case "echo":
      body.classList.add("theme-echo");
      break;
    case "silence":
      body.classList.add("theme-silence");
      break;
  }
}

document.getElementById("dreamInput").disabled = true;
document.getElementById("dreamInput").placeholder = "Enter name first...";

const userNameInput = document.createElement("input");
userNameInput.className = "dream-input";
userNameInput.placeholder = "Enter your name to begin...";
userNameInput.addEventListener("keypress", function(e) {
  if (e.key === "Enter") {
    userName = this.value.trim();
    if (userName) {
      document.getElementById("dreamOutput").textContent = "Welcome, " + userName + ". Dreamchat is listening.";
      document.getElementById("dreamInput").disabled = false;
      document.getElementById("dreamInput").placeholder = "Whisper one word...";
      this.style.display = "none";
    }
  }
});
document.querySelector(".dreamchat").prepend(userNameInput);


function echoResponse(input, thread) {
  const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
  const filtered = log.filter(entry => entry.thread === thread);
  const freq = {};
  filtered.forEach(entry => {
    freq[entry.text] = (freq[entry.text] || 0) + 1;
  });
  const repeated = Object.keys(freq).filter(word => freq[word] > 1);
  if (repeated.includes(input)) {
    return `üîÅ ‚Äú${input}‚Äù echoes through this thread (${freq[input]} times).`;
  } else if (filtered.length > 6 && repeated.length > 0) {
    return `üß† Memory loop forming: ${repeated.join(", ")}.`;
  }
  return null;
}


document.getElementById("dreamInput").addEventListener("keypress", function(e) {
  if (e.key === "Enter") {
    const input = this.value.trim().toLowerCase();
    dreamMemory.push(input);
    reactToInput(input);
    let response = coreMemory[input] || `Dreamchat listens: ‚Äú${input}‚Äù enters the archive.`;
        const echo = echoResponse(input, currentThread);
        if (echo) response += " " + echo;
    document.getElementById("dreamOutput").textContent = response;
    this.value = "";
  }
});
  </script>
<script>
   function toggleRemindagraph() {
      const panel = document.getElementById("remindagraph");
      panel.style.display = (panel.style.display === "none") ? "block" : "none";
      updateRemindagraph();
    }

    
const categoryMap = {'States': ['calm', 'focus', 'numb', 'overstimulated', 'sensitive', 'forgotten'], 'Emotion': ['grief', 'love', 'fear', 'hope', 'lonely', 'safe', 'angry', 'joy'], 'Action': ['breathe', 'rest', 'build', 'remember', 'drink', 'light', 'move', 'begin'], 'Symbolic': ['echo', 'silence', 'ritual', 'shadow', 'thread', 'anchor']};
const categoryGlyphs = {'States': 'üß≠', 'Emotion': 'üåø', 'Action': '‚ö°', 'Symbolic': 'üßµ', 'Unknown': '‚ùì'};

function getCategory(word) {
  for (let cat in categoryMap) {
    if (categoryMap[cat].includes(word)) return cat;
  }
  return "Unknown";
}

function updateRemindagraph() {
  const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
  const selectedThread = document.getElementById("threadFilter")?.value || "All";
  const grouped = {};
  log.forEach(entry => {
    if (selectedThread !== "All" && entry.thread !== selectedThread) return;
    const category = getCategory(entry.text);
    if (!grouped[category]) grouped[category] = [];
    grouped[category].push(entry);
  });

  const container = document.getElementById("remindagraphGroups");
  container.innerHTML = "";
  for (let cat in grouped) {
    const groupDiv = document.createElement("div");
    groupDiv.innerHTML = `<strong style='color:#aefcd4;'>${categoryGlyphs[cat] || ""} ${cat}</strong>`;
    const ul = document.createElement("ul");
    ul.style.listStyleType = "none";
    grouped[cat].slice(-10).reverse().forEach(entry => {
      const li = document.createElement("li");
      li.textContent = `${entry.time} ‚Äî ‚Äú${entry.text}‚Äù`;
      ul.appendChild(li);
    });
    groupDiv.appendChild(ul);
    container.appendChild(groupDiv);
  }
}


function updateRemindagraph() { // original entry point
      const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
      const ul = document.getElementById("remindagraphLog");
      ul.innerHTML = "";
      log.slice(-15).reverse().forEach(entry => {
        const li = document.createElement("li");
        li.textContent = `${entry.time}: ‚Äú${entry.text}‚Äù`;
        ul.appendChild(li);
      });
    }

    
function toggleSigil(word) {
  const stars = JSON.parse(localStorage.getItem("sigilWords") || "[]");
  if (!stars.includes(word)) stars.push(word);
  localStorage.setItem("sigilWords", JSON.stringify(stars));
}



function handleCommand(cmd) {
  const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
  const filtered = log.filter(entry => entry.thread === currentThread);
  const words = filtered.map(e => e.text);

  if (cmd === "::reflect") {
    const lastThree = words.slice(-3);
    return "ü™û Reflecting: " + lastThree.join(" ‚Üí ");
  }

  if (cmd === "::echo") {
    const freq = {};
    words.forEach(w => freq[w] = (freq[w] || 0) + 1);
    const repeated = Object.keys(freq).filter(k => freq[k] > 1);
    return repeated.length ? "üîÅ Echoes: " + repeated.join(", ") : "üîá No echoes found.";
  }

  if (cmd.startsWith("::sigil ")) {
    const word = cmd.split("::sigil ")[1].trim();
    toggleSigil(word);
    return "üïØÔ∏è Word sigiled: " + word;
  }

  if (cmd === "::clear") {
    const kept = log.filter(entry => entry.thread !== currentThread);
    localStorage.setItem("remindagraphLog", JSON.stringify(kept));
    updateRemindagraph();
    return "üßπ Current thread view cleared.";
  }

  return null;
}


function logToRemindagraph(text) {
      const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
      log.push({ text: text, time: new Date().toLocaleTimeString(), thread: currentThread });
      localStorage.setItem("remindagraphLog", JSON.stringify(log));
    }

    
    let dreamState = "awaitingName";
    const inputBox = document.getElementById("dreamInput");
    inputBox.addEventListener("keypress", function(e) {
      if (e.key === "Enter") {
        const val = this.value.trim().toLowerCase();
        if (dreamState === "awaitingName") {
          userName = val.charAt(0).toUpperCase() + val.slice(1);
          document.getElementById("dreamOutput").textContent = "Welcome, " + userName + ". Now whisper one word to start mapping mind.";
          inputBox.placeholder = "Whisper one word...";
          dreamState = "active";
          this.value = "";
        } else {
          logToRemindagraph(val);
          reactToInput(val);
          const response = coreMemory[val] || `üìú ${userName}, Dreamchat archives: ‚Äú${val}‚Äù`;
          document.getElementById("dreamOutput").textContent = response;
          this.value = "";
        }
      }
    });
    
    const oldListener = document.getElementById("dreamInput").onkeypress;
    
function echoResponse(input, thread) {
  const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
  const filtered = log.filter(entry => entry.thread === thread);
  const freq = {};
  filtered.forEach(entry => {
    freq[entry.text] = (freq[entry.text] || 0) + 1;
  });
  const repeated = Object.keys(freq).filter(word => freq[word] > 1);
  if (repeated.includes(input)) {
    return `üîÅ ‚Äú${input}‚Äù echoes through this thread (${freq[input]} times).`;
  } else if (filtered.length > 6 && repeated.length > 0) {
    return `üß† Memory loop forming: ${repeated.join(", ")}.`;
  }
  return null;
}


document.getElementById("dreamInput").addEventListener("keypress", function(e) {
      if (e.key === "Enter") {
        const input = this.value.trim().toLowerCase();
        logToRemindagraph(input);
      }
    });
  </script>
<script>
   const categoryMap = {
      "States": ['calm', 'focus', 'numb', 'overstimulated', 'sensitive', 'forgotten', 'tired', 'anxious'],
      "Emotion": ['grief', 'love', 'fear', 'hope', 'lonely', 'safe', 'angry', 'joy'],
      "Action": ['breathe', 'rest', 'build', 'remember', 'drink', 'light', 'move', 'begin'],
      "Symbolic": ['echo', 'silence', 'ritual', 'shadow', 'thread', 'anchor']
    };

    function getCategory(word) {
      for (let cat in categoryMap) {
        if (categoryMap[cat].includes(word)) return cat;
      }
      return "Unknown";
    }

    function toggleRemindagraph() {
      const panel = document.getElementById("remindagraph");
      panel.style.display = (panel.style.display === "none") ? "block" : "none";
      updateRemindagraph();
    }

    
const categoryMap = {'States': ['calm', 'focus', 'numb', 'overstimulated', 'sensitive', 'forgotten'], 'Emotion': ['grief', 'love', 'fear', 'hope', 'lonely', 'safe', 'angry', 'joy'], 'Action': ['breathe', 'rest', 'build', 'remember', 'drink', 'light', 'move', 'begin'], 'Symbolic': ['echo', 'silence', 'ritual', 'shadow', 'thread', 'anchor']};
const categoryGlyphs = {'States': 'üß≠', 'Emotion': 'üåø', 'Action': '‚ö°', 'Symbolic': 'üßµ', 'Unknown': '‚ùì'};

function getCategory(word) {
  for (let cat in categoryMap) {
    if (categoryMap[cat].includes(word)) return cat;
  }
  return "Unknown";
}

function updateRemindagraph() {
  const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
  const selectedThread = document.getElementById("threadFilter")?.value || "All";
  const grouped = {};
  log.forEach(entry => {
    if (selectedThread !== "All" && entry.thread !== selectedThread) return;
    const category = getCategory(entry.text);
    if (!grouped[category]) grouped[category] = [];
    grouped[category].push(entry);
  });

  const container = document.getElementById("remindagraphGroups");
  container.innerHTML = "";
  for (let cat in grouped) {
    const groupDiv = document.createElement("div");
    groupDiv.innerHTML = `<strong style='color:#aefcd4;'>${categoryGlyphs[cat] || ""} ${cat}</strong>`;
    const ul = document.createElement("ul");
    ul.style.listStyleType = "none";
    grouped[cat].slice(-10).reverse().forEach(entry => {
      const li = document.createElement("li");
      li.textContent = `${entry.time} ‚Äî ‚Äú${entry.text}‚Äù`;
      ul.appendChild(li);
    });
    groupDiv.appendChild(ul);
    container.appendChild(groupDiv);
  }
}


function updateRemindagraph() { // original entry point
      const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
      const grouped = {};
      const selectedThread = document.getElementById('threadFilter')?.value || 'All';
      log.forEach(entry => {
        if (selectedThread !== 'All' && entry.thread !== selectedThread) return;
        const category = getCategory(entry.text);
        if (!grouped[category]) grouped[category] = [];
        grouped[category].push(entry);
      });

      const container = document.getElementById("remindagraphGroups");
      container.innerHTML = "";
      for (let cat in grouped) {
        const groupDiv = document.createElement("div");
        groupDiv.innerHTML = `<strong style='color:#aefcd4;'>${cat}</strong>`;
        const ul = document.createElement("ul");
        ul.style.listStyleType = "none";
        grouped[cat].slice(-10).reverse().forEach(entry => {
          const li = document.createElement("li");
          li.textContent = `${entry.time} ‚Äî ‚Äú${entry.text}‚Äù`;
          ul.appendChild(li);
        });
        groupDiv.appendChild(ul);
        container.appendChild(groupDiv);
      }
    }

    
function toggleSigil(word) {
  const stars = JSON.parse(localStorage.getItem("sigilWords") || "[]");
  if (!stars.includes(word)) stars.push(word);
  localStorage.setItem("sigilWords", JSON.stringify(stars));
}



function handleCommand(cmd) {
  const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
  const filtered = log.filter(entry => entry.thread === currentThread);
  const words = filtered.map(e => e.text);

  if (cmd === "::reflect") {
    const lastThree = words.slice(-3);
    return "ü™û Reflecting: " + lastThree.join(" ‚Üí ");
  }

  if (cmd === "::echo") {
    const freq = {};
    words.forEach(w => freq[w] = (freq[w] || 0) + 1);
    const repeated = Object.keys(freq).filter(k => freq[k] > 1);
    return repeated.length ? "üîÅ Echoes: " + repeated.join(", ") : "üîá No echoes found.";
  }

  if (cmd.startsWith("::sigil ")) {
    const word = cmd.split("::sigil ")[1].trim();
    toggleSigil(word);
    return "üïØÔ∏è Word sigiled: " + word;
  }

  if (cmd === "::clear") {
    const kept = log.filter(entry => entry.thread !== currentThread);
    localStorage.setItem("remindagraphLog", JSON.stringify(kept));
    updateRemindagraph();
    return "üßπ Current thread view cleared.";
  }

  return null;
}


function logToRemindagraph(text) {
      const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
      log.push({ text: text, time: new Date().toLocaleTimeString(), thread: currentThread });
      localStorage.setItem("remindagraphLog", JSON.stringify(log));
    }

    
function echoResponse(input, thread) {
  const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
  const filtered = log.filter(entry => entry.thread === thread);
  const freq = {};
  filtered.forEach(entry => {
    freq[entry.text] = (freq[entry.text] || 0) + 1;
  });
  const repeated = Object.keys(freq).filter(word => freq[word] > 1);
  if (repeated.includes(input)) {
    return `üîÅ ‚Äú${input}‚Äù echoes through this thread (${freq[input]} times).`;
  } else if (filtered.length > 6 && repeated.length > 0) {
    return `üß† Memory loop forming: ${repeated.join(", ")}.`;
  }
  return null;
}


document.getElementById("dreamInput").addEventListener("keypress", function(e) {
      if (e.key === "Enter") {
        const input = this.value.trim().toLowerCase();
        logToRemindagraph(input);
      }
    });
  </script>
<script>
window.addEventListener("load", function() {
  const loader = document.getElementById("loadingScreen");
  if (loader) {
    setTimeout(() => {
      loader.style.opacity = 0;
      setTimeout(() => loader.style.display = "none", 800);
    }, 1800);
  }
});
</script>
<script>
// Make sidebar sections toggle visibility
function showSection(id) {
  const sections = document.querySelectorAll('.section');
  sections.forEach(sec => sec.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

// Track current thread and show mood state
let currentThread = null;

function setThread(mood) {
  currentThread = mood.toLowerCase();
  document.getElementById('poem').innerHTML = `üåÄ You have entered the <strong>${mood}</strong> thread. Whisper into Dreamchat.`;
  document.getElementById('back').style.display = "block";
  logToRemindagraph(mood.toLowerCase());
}

// Reset thread state
function reset() {
  currentThread = null;
  document.getElementById('poem').innerHTML = "";
  document.getElementById('back').style.display = "none";
}
</script>
<script>
function supportMe() {
  window.open('https://www.paypal.com/ncp/payment/8GYVBJ5P4RHA6', '_blank');
}

function dsoulAlert() {
  alert("üß† D-Soul is reaching capacity...
More memory needed to unlock further resonance.");
}
</script>
<script>
window.submitEchoWeight = function () {
  const clarity = document.getElementById("clarity").value;
  const weight = document.getElementById("weight").value;
  const emotion = document.getElementById("emotion").value;
  const dream = document.getElementById("dreamImpression").value;

  if (!clarity || !emotion) {
    alert("The cat raises an eyebrow. Please answer more completely.");
    return;
  }

  const echoEntry = {
    clarity,
    weight,
    emotion,
    dream,
    time: new Date().toISOString()
  };

  localStorage.setItem("echoWeightEntry", JSON.stringify(echoEntry));

  document.getElementById("riddleGate").style.display = "none";
  document.getElementById("trailCore").style.display = "block";

  if (typeof db !== "undefined" && db.collection) {
    db.collection("echo_weight_entries").add(echoEntry);
  }
};

window.showRoom1 = function () {
  document.getElementById("room1").style.display = "block";
};
</script>
<script>
window.showSection = function(id) {
  const sections = document.querySelectorAll('.section');
  sections.forEach(sec => sec.classList.remove('active'));
  const target = document.getElementById(id);
  if (target) target.classList.add('active');
};
</script>
<script>
function showRoom2() {
  const room2 = document.getElementById("room2");
  const continueBtn = room2.querySelector("button");
  continueBtn.style.display = "none";
  room2.style.display = "block";
  setTimeout(() => {
    continueBtn.style.display = "inline-block";
  }, 5000); // 5 seconds wait
}
</script>
<script>
function showRoom3() {
  document.getElementById("room3").style.display = "block";
  document.getElementById("room2").style.display = "none";
}
function showRoom2() {
  const room2 = document.getElementById("room2");
  const continueBtn = room2.querySelector("button");
  continueBtn.style.display = "none";
  room2.style.display = "block";
  setTimeout(() => {
    continueBtn.style.display = "inline-block";
    continueBtn.onclick = showRoom3;
  }, 5000); // 5 seconds wait
}
</script>
<div class="section" id="glyphs">
<h1>Symbol Guide</h1>
<ul style="line-height:1.6;">
<li><strong>üß≠ States</strong>: internal tuning (e.g. calm, numb, overstimulated)</li>
<li><strong>üåø Emotion</strong>: raw feelings (e.g. grief, joy, love)</li>
<li><strong>‚ö° Action</strong>: verbs, intent (e.g. build, begin, breathe)</li>
<li><strong>üßµ Symbolic</strong>: metaphors (e.g. thread, echo, anchor)</li>
</ul>
<p>Each word you whisper is categorized and remembered. These glyphs help you navigate your emotional terrain.</p>
</div><div class="section" id="glyphGrid"><h1>Choose a Symbol</h1><p>Click a glyph to receive its whisper.</p><div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-top: 1rem;"><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Grief</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Wonder</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Thread</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Silence</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Longing</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Focus</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Build</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Anchor</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Joy</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Dread</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Remember</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Begin</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Seeker</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Overstimulated</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Numb</div></div><div style="text-align:center; cursor:pointer;"><div style="margin-top:0.5rem; font-size:0.9rem; color:#aefcd4;">Safe</div></div></div></div></div><h2 style="text-align:center; color:#aefcd4; margin-bottom:1rem;">üï∏Ô∏è Mood Weave</h2></div><script>
function triggerGlyphWhisper(label, whisper) {
  document.getElementById("dreamOutput").textContent = whisper;
  const log = JSON.parse(localStorage.getItem("remindagraphLog") || "[]");
  log.push({ text: label.toLowerCase(), time: new Date().toLocaleTimeString(), thread: currentThread });
  localStorage.setItem("remindagraphLog", JSON.stringify(log));
}
</script><script>
document.querySelectorAll('input')[0].addEventListener('keydown', function(e) {
  if (e.key === 'Enter' && this.value.trim().length > 0) {
    document.getElementById('dreamchat').style.display = 'block';
  }
});
</script><script>
const echoData = {
  labels: ["Grief", "Wonder", "Thread", "Silence", "Longing", "Focus", "Build", "Anchor",
           "Joy", "Dread", "Remember", "Begin", "Seeker", "Overstimulated", "Numb", "Safe", "Suspicion"],
  counts: new Array(17).fill(0),
  glyphs: ["üåø", "üß≠", "üßµ", "üßµ", "üåø", "‚ö°", "‚ö°", "üßµ", "üåø", "üåø", "‚ö°", "‚ö°", "üß≠", "üß≠", "üß≠", "üåø", "üëÅÔ∏è"],
  glyphMap: {
    "Grief": "grief", "Wonder": "wonder", "Thread": "thread", "Silence": "silence",
    "Longing": "longing", "Focus": "focus", "Build": "build", "Anchor": "anchor",
    "Joy": "joy", "Dread": "dread", "Remember": "remember", "Begin": "begin",
    "Seeker": "seeker", "Overstimulated": "overstimulated", "Numb": "numb", "Safe": "safe",
    "Suspicion": "suspicion"
  },
  suspicionWords: ["fake", "trap", "why", "glitch", "doubt", "broken", "suspicious"],
  echoLines: {
    "Grief": "The ache folds itself into morning.",
    "Wonder": "You are in orbit, sensing patterns beneath things.",
    "Thread": "You‚Äôre not alone ‚Äî the thread is intact.",
    "Silence": "Nothing speaks louder than what wasn‚Äôt said.",
    "Longing": "The thing you‚Äôre missing is listening for you too.",
    "Focus": "Your signal sharpens. Static fades.",
    "Build": "Hands remember what the mind forgets.",
    "Anchor": "Drop weight. Find ground. Return.",
    "Joy": "You‚Äôre glowing ‚Äî even the shadow notices.",
    "Dread": "Your pulse maps a hidden landscape.",
    "Remember": "Old echoes surface. They‚Äôre ready.",
    "Begin": "This moment hums with possibility.",
    "Seeker": "Your compass stirs, and something answers.",
    "Overstimulated": "Step back. The signal is jagged today.",
    "Numb": "There‚Äôs feeling underneath ‚Äî it‚Äôs just quiet.",
    "Safe": "You‚Äôve reached a clearing. Rest here.",
    "Suspicion": "Even doubt has something to show you."
  }
};

function drawEchoChart() {
  const canvas = document.getElementById("echoChart");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const max = Math.max(...echoData.counts, 1);
  const barWidth = 30;
  const spacing = 15;
  echoData.counts.forEach((val, i) => {
    const x = i * (barWidth + spacing) + 30;
    const h = (val / max) * 150;
    ctx.fillStyle = "#aefcd4";
    ctx.fillRect(x, 200 - h, barWidth, h);
    ctx.font = "20px serif";
    ctx.fillText(echoData.glyphs[i], x + 5, 190 - h); // glyph above bar
    ctx.font = "11px Georgia";
    ctx.fillText(echoData.labels[i], x - 2, 220);
  });
}

function processManualInput(value) {
  value = value.toLowerCase();
  let matched = false;
  echoData.labels.forEach((label, i) => {
    if (value.includes(echoData.glyphMap[label]) || 
        (label === "Suspicion" && echoData.suspicionWords.includes(value))) {
      echoData.counts[i]++;
      matched = true;
      const echo = echoData.echoLines[label];
      appendEchoLine(`you said *${value}* ‚Äî ${echo}`);
    }
  });
  if (!matched) appendEchoLine(`"${value}" entered the field, unclassified.`);
  localStorage.setItem("echoCounts", JSON.stringify(echoData.counts));
  drawEchoChart();
}

function appendEchoLine(text) {
  const out = document.getElementById("dreamOutput");
  const line = document.createElement("div");
  line.style.marginTop = "0.5rem";
  line.style.opacity = "0.8";
  line.innerHTML = text;
  out.prepend(line);
}

window.onload = () => {
  const stored = localStorage.getItem("echoCounts");
  if (stored) echoData.counts = JSON.parse(stored);
  drawEchoChart();
};
</script><script>
const echoData = {
  labels: ["Grief", "Wonder", "Thread", "Silence", "Longing", "Focus", "Build", "Anchor",
           "Joy", "Dread", "Remember", "Begin", "Seeker", "Overstimulated", "Numb", "Safe", "Suspicion"],
  glyphMap: {
    "Grief": "grief", "Wonder": "wonder", "Thread": "thread", "Silence": "silence",
    "Longing": "longing", "Focus": "focus", "Build": "build", "Anchor": "anchor",
    "Joy": "joy", "Dread": "dread", "Remember": "remember", "Begin": "begin",
    "Seeker": "seeker", "Overstimulated": "overstimulated", "Numb": "numb", "Safe": "safe",
    "Suspicion": "suspicion"
  },
  suspicionWords: ["fake", "trap", "why", "glitch", "doubt", "broken", "suspicious"],
  values: new Array(17).fill(0),
  decayRate: 0.95,
  echoLines: {
    "Grief": "The ache folds itself into morning.",
    "Wonder": "You are in orbit, sensing patterns beneath things.",
    "Thread": "You‚Äôre not alone ‚Äî the thread is intact.",
    "Silence": "Nothing speaks louder than what wasn‚Äôt said.",
    "Longing": "The thing you‚Äôre missing is listening for you too.",
    "Focus": "Your signal sharpens. Static fades.",
    "Build": "Hands remember what the mind forgets.",
    "Anchor": "Drop weight. Find ground. Return.",
    "Joy": "You‚Äôre glowing ‚Äî even the shadow notices.",
    "Dread": "Your pulse maps a hidden landscape.",
    "Remember": "Old echoes surface. They‚Äôre ready.",
    "Begin": "This moment hums with possibility.",
    "Seeker": "Your compass stirs, and something answers.",
    "Overstimulated": "Step back. The signal is jagged today.",
    "Numb": "There‚Äôs feeling underneath ‚Äî it‚Äôs just quiet.",
    "Safe": "You‚Äôve reached a clearing. Rest here.",
    "Suspicion": "Even doubt has something to show you."
  }
};

function drawLineGraph() {
  const canvas = document.getElementById("echoChart");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const maxVal = 100;
  const midY = 150;
  const stepX = (canvas.width - 60) / (echoData.values.length - 1);

  ctx.beginPath();
  ctx.moveTo(30, midY - echoData.values[0]);
  for (let i = 1; i < echoData.values.length; i++) {
    const x = 30 + i * stepX;
    const y = midY - echoData.values[i];
    ctx.lineTo(x, y);
  }
  ctx.strokeStyle = "#aefcd4";
  ctx.lineWidth = 2;
  ctx.stroke();

  // Draw glyphs at each point
  for (let i = 0; i < echoData.values.length; i++) {
    const x = 30 + i * stepX;
    const y = midY - echoData.values[i];
    ctx.font = "16px serif";
    ctx.fillText("‚Ä¢", x - 2, y - 5);
  }
}

function updateGraph() {
  echoData.values = echoData.values.map(v => v * echoData.decayRate);
  drawLineGraph();
  requestAnimationFrame(updateGraph);
}

function processManualInput(value) {
  value = value.toLowerCase();
  let matched = false;
  echoData.labels.forEach((label, i) => {
    if (value.includes(echoData.glyphMap[label]) || 
        (label === "Suspicion" && echoData.suspicionWords.includes(value))) {
      echoData.values[i] = 50 + Math.random() * 30;
      matched = true;
      appendEchoLine(`you said *${value}* ‚Äî ${echoData.echoLines[label]}`);
    }
  });
  if (!matched) {
    const randomIndex = Math.floor(Math.random() * echoData.values.length);
    echoData.values[randomIndex] = 20 + Math.random() * 15;
    appendEchoLine(`"${value}" entered the field, unclassified.`);
  }
}

function appendEchoLine(text) {
  const out = document.getElementById("dreamOutput");
  const line = document.createElement("div");
  line.style.marginTop = "0.5rem";
  line.style.opacity = "0.8";
  line.innerHTML = text;
  out.prepend(line);
}

window.onload = () => {
  updateGraph();
};
</script><script>
function drawMoodWeave() {
  const canvas = document.getElementById("moodWeave");
  const ctx = canvas.getContext("2d");
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;
  const radius = 140;
  const moods = echoData.labels;
  const values = echoData.values.map(v => Math.min(v / 60, 1)); // normalize

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw web grid
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 1;
  for (let r = 0.2; r <= 1.0; r += 0.2) {
    ctx.beginPath();
    for (let i = 0; i < moods.length; i++) {
      const angle = (i / moods.length) * 2 * Math.PI;
      const x = cx + Math.cos(angle) * radius * r;
      const y = cy + Math.sin(angle) * radius * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  // Draw shape
  ctx.beginPath();
  for (let i = 0; i < moods.length; i++) {
    const angle = (i / moods.length) * 2 * Math.PI;
    const dist = radius * values[i];
    const x = cx + Math.cos(angle) * dist;
    const y = cy + Math.sin(angle) * dist;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fillStyle = "rgba(174, 252, 212, 0.2)";
  ctx.strokeStyle = "#aefcd4";
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fill();

  // Mood labels
  ctx.font = "10px Georgia";
  ctx.fillStyle = "#aefcd4";
  for (let i = 0; i < moods.length; i++) {
    const angle = (i / moods.length) * 2 * Math.PI;
    const x = cx + Math.cos(angle) * (radius + 15);
    const y = cy + Math.sin(angle) * (radius + 15);
    ctx.fillText(moods[i], x - 15, y);
  }
}

function updateGraph() {
  echoData.values = echoData.values.map(v => v * echoData.decayRate);
  drawLineGraph();
  drawMoodWeave();
  requestAnimationFrame(updateGraph);
}
</script><script>
let promptNetwork = [];

function processManualInput(value) {
  value = value.trim().toLowerCase();
  if (!value) return;

  const out = document.getElementById("dreamOutput");
  const line = document.createElement("div");
  line.innerText = `"${value}" whispered into the field.`;
  out.prepend(line);

  // Network: connect last prompt to current
  if (promptNetwork.length > 0) {
    const last = promptNetwork[promptNetwork.length - 1];
    promptNetwork.push({ word: value, from: last.word });
  } else {
    promptNetwork.push({ word: value, from: null });
  }

  drawOrganicWeb();
}

function drawOrganicWeb() {
  const canvas = document.getElementById("moodWeave");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;
  const radius = 150;

  const angleStep = (2 * Math.PI) / promptNetwork.length;
  let coords = {};

  promptNetwork.forEach((node, i) => {
    const angle = i * angleStep;
    const dist = 80 + Math.min(i * 10, radius);
    const x = cx + Math.cos(angle) * dist;
    const y = cy + Math.sin(angle) * dist;
    coords[node.word] = { x, y };
    ctx.beginPath();
    ctx.arc(x, y, 5, 0, 2 * Math.PI);
    ctx.fillStyle = "#aefcd4";
    ctx.fill();
    ctx.font = "10px Georgia";
    ctx.fillText(node.word, x + 8, y);
  });

  promptNetwork.forEach(node => {
    if (node.from && coords[node.from]) {
      const from = coords[node.from];
      const to = coords[node.word];
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = "#6affdf";
      ctx.stroke();
    }
  });
}
</script><script>
const fixedLegs = ["Overstimulated", "Numb", "Sensitive", "Seeker", "Forgotten"];

function drawOrganicWeb() {
  const canvas = document.getElementById("moodWeave");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;
  const radius = 130;

  // Draw fixed 5 legs
  const fixedCoords = {};
  fixedLegs.forEach((label, i) => {
    const angle = (i / fixedLegs.length) * 2 * Math.PI - Math.PI / 2;
    const x = cx + Math.cos(angle) * radius;
    const y = cy + Math.sin(angle) * radius;
    fixedCoords[label] = { x, y };

    // Draw fixed point
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, 2 * Math.PI);
    ctx.fillStyle = "#5feacf";
    ctx.fill();
    ctx.font = "11px Georgia";
    ctx.fillText(label, x - 25, y - 8);
  });

  // Dynamic prompts
  const promptCoords = {};
  const dynamicRadius = radius * 0.7;
  const angleStep = (2 * Math.PI) / Math.max(promptNetwork.length, 1);

  promptNetwork.forEach((node, i) => {
    const angle = i * angleStep - Math.PI / 2;
    const dist = dynamicRadius + Math.random() * 10;
    const x = cx + Math.cos(angle) * dist;
    const y = cy + Math.sin(angle) * dist;
    promptCoords[node.word] = { x, y };

    ctx.beginPath();
    ctx.arc(x, y, 4, 0, 2 * Math.PI);
    ctx.fillStyle = "#aefcd4";
    ctx.fill();
    ctx.font = "10px Georgia";
    ctx.fillText(node.word, x + 6, y + 4);
  });

  // Lines from prompt to fixed base (random assignment for now)
  promptNetwork.forEach((node, i) => {
    const base = fixedLegs[i % fixedLegs.length];
    const from = fixedCoords[base];
    const to = promptCoords[node.word];
    if (from && to) {
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = "#88ffe0";
      ctx.stroke();
    }
  });

  // Prompt-to-prompt links
  promptNetwork.forEach((node) => {
    if (node.from && promptCoords[node.from]) {
      const from = promptCoords[node.from];
      const to = promptCoords[node.word];
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = "#44dcd1";
      ctx.stroke();
    }
  });
}
</script><script>
const moodLabels = ['Overstimulated', 'Numb', 'Sensitive', 'Seeker', 'Forgotten'];
let moodScores = [0.5, 0.5, 0.5, 0.5, 0.5];

const ctx = document.getElementById('moodRadar').getContext('2d');
const moodRadarChart = new Chart(ctx, {
  type: 'radar',
  data: {
    labels: moodLabels,
    datasets: [{
      label: 'Mood Web',
      data: moodScores,
      fill: true,
      backgroundColor: 'rgba(102, 153, 255, 0.2)',
      borderColor: 'rgba(102, 153, 255, 1)',
      pointBackgroundColor: 'rgba(102, 153, 255, 1)'
    }]
  },
  options: {
    scales: {
      r: {
        angleLines: { color: '#444' },
        grid: { color: '#444' },
        pointLabels: { color: '#aefcd4' },
        ticks: {
          display: false,
          min: 0,
          max: 1
        }
      }
    },
    plugins: {
      legend: { display: false }
    }
  }
});

const moodInfluences = {
  "overwhelmed": "Overstimulated",
  "chaotic": "Overstimulated",
  "numb": "Numb",
  "blank": "Numb",
  "sensitive": "Sensitive",
  "gentle": "Sensitive",
  "seeking": "Seeker",
  "curious": "Seeker",
  "forgotten": "Forgotten",
  "alone": "Forgotten"
};

function updateMoodRadar(word) {
  const normalized = word.toLowerCase();
  let updated = false;
  for (let keyword in moodInfluences) {
    if (normalized.includes(keyword)) {
      const mood = moodInfluences[keyword];
      const index = moodLabels.indexOf(mood);
      if (index !== -1) {
        moodScores[index] = Math.min(1, moodScores[index] + 0.05);
        updated = true;
      }
    }
  }

  if (updated) {
    for (let i = 0; i < moodScores.length; i++) {
      moodScores[i] = Math.max(0, moodScores[i] * 0.98); // slight decay
    }
    moodRadarChart.data.datasets[0].data = moodScores;
    moodRadarChart.update();
  }
}

// Attach to Dreamchat keypress
document.getElementById("dreamInput").addEventListener("keypress", function(e) {
  if (e.key === "Enter") {
    const word = this.value.trim().toLowerCase();
    if (word) {
      updateMoodRadar(word);
    }
  }
});
</script>
<script>
const moodInfluences = {
  "overwhelmed": "Overstimulated",
  "chaotic": "Overstimulated",
  "numb": "Numb",
  "blank": "Numb",
  "sensitive": "Sensitive",
  "gentle": "Sensitive",
  "seeking": "Seeker",
  "curious": "Seeker",
  "forgotten": "Forgotten",
  "alone": "Forgotten",
  "wired": "Overstimulated",
  "dull": "Numb",
  "tender": "Sensitive",
  "wander": "Seeker",
  "missing": "Forgotten",
  "fragile": "Sensitive",
  "lost": "Forgotten",
  "spiraling": "Overstimulated",
  "quiet": "Numb"
};

const poeticMessages = {
  "Overstimulated": "‚ö° The edges sharpen, but there's rhythm beneath chaos.",
  "Numb": "üåë Stillness isn‚Äôt absence ‚Äî it‚Äôs waiting.",
  "Sensitive": "üåä The current moves gently. You‚Äôre tuned to the subtle.",
  "Seeker": "üîç Your question is a compass. Keep going.",
  "Forgotten": "üß∑ What was lost wants to return ‚Äî gently, patiently."
};

let promptMemory = JSON.parse(localStorage.getItem("moodPromptMemory") || "[]");

function updateMoodRadar(word) {
  if (promptMemory.length >= 20) {
    document.getElementById("dreamOutput").innerHTML = "üß† Mood Web memory full. Rest in the shape it formed.";
    return;
  }

  const normalized = word.toLowerCase();
  let updated = false;

  for (let keyword in moodInfluences) {
    if (normalized.includes(keyword)) {
      const mood = moodInfluences[keyword];
      const index = moodLabels.indexOf(mood);
      if (index !== -1) {
        moodScores[index] = Math.min(1, moodScores[index] + 0.05);
        updated = true;

        // Poetic message shown below chart
        const line = document.createElement("div");
        line.innerText = poeticMessages[mood] || "‚ú® The web listens.";
        line.style.marginTop = "0.6rem";
        line.style.opacity = "0.8";
        document.getElementById("dreamOutput").prepend(line);
      }
    }
  }

  if (updated) {
    for (let i = 0; i < moodScores.length; i++) {
      moodScores[i] = Math.max(0, moodScores[i] * 0.98); // decay
    }
    moodRadarChart.data.datasets[0].data = moodScores;
    moodRadarChart.update();
  }

  promptMemory.push(word);
  localStorage.setItem("moodPromptMemory", JSON.stringify(promptMemory));
}

// Attach to whisper input
document.getElementById("dreamInput").addEventListener("keypress", function(e) {
  if (e.key === "Enter") {
    const word = this.value.trim().toLowerCase();
    if (word) {
      updateMoodRadar(word);
    }
  }
});
</script>
<script>
const moodInfluences = {
  "overwhelmed": "Overstimulated",
  "chaotic": "Overstimulated",
  "numb": "Numb",
  "blank": "Numb",
  "sensitive": "Sensitive",
  "gentle": "Sensitive",
  "seeking": "Seeker",
  "curious": "Seeker",
  "forgotten": "Forgotten",
  "alone": "Forgotten",
  "wired": "Overstimulated",
  "dull": "Numb",
  "tender": "Sensitive",
  "wander": "Seeker",
  "missing": "Forgotten",
  "fragile": "Sensitive",
  "lost": "Forgotten",
  "spiraling": "Overstimulated",
  "quiet": "Numb"
};

const poeticMessages = {
  "Overstimulated": "‚ö° The edges sharpen, but there's rhythm beneath chaos.",
  "Numb": "üåë Stillness isn‚Äôt absence ‚Äî it‚Äôs waiting.",
  "Sensitive": "üåä The current moves gently. You‚Äôre tuned to the subtle.",
  "Seeker": "üîç Your question is a compass. Keep going.",
  "Forgotten": "üß∑ What was lost wants to return ‚Äî gently, patiently."
};

let promptMemory = JSON.parse(localStorage.getItem("moodPromptMemory") || "[]");

function updateMoodRadar(word) {
  if (promptMemory.length >= 20) {
    document.getElementById("moodWhisper").innerHTML = "üß† Mood Web memory full. Rest in the shape it formed.";
    return;
  }

  const normalized = word.toLowerCase();
  let updated = false;
  let mood = null;

  for (let keyword in moodInfluences) {
    if (normalized.includes(keyword)) {
      mood = moodInfluences[keyword];
      const index = moodLabels.indexOf(mood);
      if (index !== -1) {
        moodScores[index] = Math.min(1, moodScores[index] + 0.05);
        updated = true;
      }
    }
  }

  if (updated) {
    for (let i = 0; i < moodScores.length; i++) {
      moodScores[i] = Math.max(0, moodScores[i] * 0.98);
    }
    moodRadarChart.data.datasets[0].data = moodScores;
    moodRadarChart.update();
  }

  promptMemory.push(word);
  localStorage.setItem("moodPromptMemory", JSON.stringify(promptMemory));

  const moodWhisperDiv = document.getElementById("moodWhisper");
  const message = poeticMessages[mood] || "‚ú® The web listens.";
  const line = document.createElement("div");
  line.innerText = message;
  line.style.marginTop = "1rem";
  line.style.fontStyle = "italic";
  line.style.opacity = "0.9";
  moodWhisperDiv.prepend(line);
}

window.addEventListener("DOMContentLoaded", () => {
  const input = document.getElementById("dreamInput");
  const output = document.getElementById("dreamOutput");

  input.addEventListener("keydown", function(e) {
    if (e.key === "Enter") {
      e.preventDefault();
      const word = this.value.trim();
      if (!word) return;
      this.value = "";

      // Mood Web update
      updateMoodRadar(word);

      // Dreamchat whisper
      const line = document.createElement("div");
      line.innerText = "üó£Ô∏è " + word;
      line.style.marginTop = "0.5rem";
      output.prepend(line);
    }
  });
});
</script>
